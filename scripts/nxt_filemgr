#!/usr/bin/env python
#
# nxt_filemgr program -- Updated from nxt_filer 
# Was: nxt_filer program -- Simple GUI to manage files on a LEGO Mindstorms NXT
# Copyright (C) 2006  Douglas P Lau
# Copyright (C) 2010  rhn
# Copyright (C) 2017  TC Wan
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

WIN_WIDTH = 800
WIN_HEIGHT = 400

FILENAME_MINWIDTH = 100
FILENAME_MAXWIDTH = 400
FILENAME_WIDTH = 200
FILESIZE_MINWIDTH = 40
FILESIZE_MAXWIDTH = 120
FILESIZE_WIDTH = 80

FILELIST_MINWIDTH = 0.6 * WIN_WIDTH
FILELIST_MAXWIDTH = 0.8 * WIN_WIDTH
FILELIST_HEIGHT = 100

import cStringIO
# Use Gtk+ 2.x
#import gtk
# Use Gtk+ 3.x
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import GObject
from gi.repository import Gtk

import os.path
import urllib2
import sys

import nxt.locator
from nxt.brick import FileFinder, FileReader, FileWriter
from nxt.utils import parse_command_line_arguments

def read_file(b, fname):
    with FileReader(b, fname) as r:
        with open(fname, 'wb') as f:
            for data in r:
                f.write(data)

class NXTListing(Gtk.ListStore):

    def __init__(self, brick):
        Gtk.ListStore.__init__(self, str, str)
        self.set_sort_column_id(0, Gtk.SortType(Gtk.SortType.ASCENDING))
        self.populate(brick, '*.*')

    def populate(self, brick, pattern):
        f = FileFinder(brick, pattern)
        for (fname, size) in f:
            self.append((fname, str(size)))

def write_file(b, fname, data):
    w = FileWriter(b, fname, len(data))
    print 'Pushing %s (%d bytes) ...' % (fname, w.size),
    sys.stdout.flush()
    w.write(data)
    print 'wrote %d bytes' % len(data)
    w.close()
        
def write_files(b, names):
    for fname in names.split('\r\n'):
        if fname:
            print 'File:', fname
            bname = os.path.basename(fname)
            url = urllib2.urlopen(fname)
            try:
                data = url.read()
            finally:
                url.close()
            print 'name %s, size: %d ' % (bname, len(data))
            write_file(b, bname, data)

class NXT_FileMgr(Gtk.Window):
 ### FIXME
 ###   TARGETS = Gtk.target_list_add_uri_targets()

    def __init__(self, brick):
        Gtk.Window.__init__(self)
        self.set_default_size(WIN_WIDTH, WIN_HEIGHT)
        self.brick = brick
        self.set_border_width(6)

        self.nxt_filelist = NXTListing(brick)
###        print '''Socket = %s''' % str(brick.sock)
        h = Gtk.Box(Gtk.Orientation.VERTICAL, 10)

        h.add(self.make_file_panel(str(brick.sock), self.nxt_filelist))
        h.add(self.make_button_panel())
        
        self.add(h)
        self.connect('destroy', self.quit)

    def make_button_panel(self):
        vb = Gtk.Box(Gtk.Orientation.VERTICAL, 0)     
 
        self.delete_button = Gtk.Button(label="Delete")
        self.delete_button.connect("clicked", self.delete_file)
        vb.pack_start(self.delete_button, True, True, 10)

        self.add_button = Gtk.Button(label="Add")
        self.add_button.connect("clicked", self.add_file)
        vb.pack_start(self.add_button, True, True, 10)

        self.exec_button = Gtk.Button(label="Execute")
        self.exec_button.connect("clicked", self.execute_file)
        vb.pack_start(self.exec_button, True, True, 10)

        return vb

    def make_file_list(self):
        tv = Gtk.TreeView()
        tv.set_headers_visible(True)
        tv.set_property('fixed_height_mode', True)
        r = Gtk.CellRendererText()
        c = Gtk.TreeViewColumn('File name', r, text=0)
        c.set_fixed_width(FILENAME_WIDTH)
        c.set_min_width(FILENAME_MINWIDTH)
        c.set_max_width(FILENAME_MAXWIDTH)
        c.set_resizable(True)
        c.set_sizing(Gtk.TreeViewColumnSizing.FIXED)
        tv.append_column(c)
        r = Gtk.CellRendererText()
        c = Gtk.TreeViewColumn('Bytes', r, text=1)
        c.set_resizable(True)
        c.set_fixed_width(FILESIZE_WIDTH)
        c.set_min_width(FILESIZE_MINWIDTH)
        c.set_max_width(FILESIZE_MAXWIDTH)
        c.set_sizing(Gtk.TreeViewColumnSizing.FIXED)
        tv.append_column(c)

#            tv.enable_model_drag_source(Gtk.gdk.BUTTON1_MASK, self.TARGETS,
#            Gtk.gdk.ACTION_DEFAULT | Gtk.gdk.ACTION_MOVE)
### FIXME
###        tv.enable_model_drag_dest(self.TARGETS, Gtk.gdk.ACTION_COPY)
#        tv.connect("drag_data_get", self.drag_data_get_data)
        tv.connect("drag_data_received", self.drag_data_received_data)

        return tv

    def make_file_panel(self, name, model):
        v = Gtk.Box(Gtk.Orientation.VERTICAL, 0)     
###        v.pack_start(Gtk.Label(name), True, True, 0)
        tv = self.make_file_list()
        tv.set_model(model)
        s = Gtk.ScrolledWindow()
        s.set_min_content_width(FILELIST_MINWIDTH)
        s.set_max_content_width(min(FILENAME_MAXWIDTH+FILESIZE_MAXWIDTH, FILELIST_MAXWIDTH))
        s.set_min_content_height(FILELIST_HEIGHT)
        s.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        s.add(tv)
        s.set_border_width(2)
        v.pack_start(s, True, False, 0)
        return v

    def drag_data_get_data(self, treeview, context, selection, target_id,
        etime):
        treeselection = treeview.get_selection()
        model, iter = treeselection.get_selected()
        data = model.get_value(iter, 0)
        print data
        selection.set(selection.target, 8, data)

    def drag_data_received_data(self, treeview, context, x, y, selection,
        info, etime):
        if context.action == Gtk.gdk.ACTION_COPY:
            write_files(self.brick, selection.data)
        # FIXME: update file listing after writing files
        # FIXME: finish context

    def	execute_file(self, widget):
        print("Running file...")
        
    def	delete_file(self, widget):
        print("Deleting file...")

    def	add_file(self, widget):
        print("Adding file...")

    def quit(self, w):
        'Quit the program'
        self.brick.sock.close()
        Gtk.main_quit()

if __name__ == '__main__':
    # FIXME: add dialog with progress bar when scanning bluetooth devices
    arguments, keyword_arguments = parse_command_line_arguments(sys.argv)

    if '--help' in arguments:
        print '''nxt_filemgr -- Simple GUI to manage files on a LEGO Mindstorms NXT
Usage:	nxt_filemgr [--host <macaddress>]'''
        exit(0)

    brick = nxt.locator.find_one_brick(keyword_arguments.get('host',None))
    win = NXT_FileMgr(brick)
    win.show_all()
    Gtk.main()
