#!/usr/bin/env python
#
# nxt_filemgr program -- Updated from nxt_filer 
# Was: nxt_filer program -- Simple GUI to manage files on a LEGO Mindstorms NXT
# Copyright (C) 2006  Douglas P Lau
# Copyright (C) 2010  rhn
# Copyright (C) 2017  TC Wan
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.


FILENAME_MINWIDTH = 100
FILENAME_MAXWIDTH = 300
FILENAME_WIDTH = 200
FILESIZE_MINWIDTH = 40
FILESIZE_MAXWIDTH = 120
FILESIZE_WIDTH = 80
FILELIST_HEIGHT = 300

### WIN_WIDTH = 400
### WIN_HEIGHT = 300
WIN_WIDTH = FILENAME_MAXWIDTH + FILESIZE_MAXWIDTH
WIN_HEIGHT = FILELIST_HEIGHT

FILELIST_MINWIDTH = 1.0 * WIN_WIDTH
FILELIST_MAXWIDTH = 1.0 * WIN_WIDTH

import cStringIO
# Use Gtk+ 3.x
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import GObject
from gi.repository import Gtk
from gi.repository import GLib

from nxt.error import FileNotFound, ModuleNotFound
from nxt.telegram import OPCODES, Telegram

import os.path
import urllib2
import sys

import nxt.locator
from nxt.brick import FileFinder, FileReader, FileWriter
from nxt.utils import parse_command_line_arguments

def play_soundfile(b, fname):
    print("Playing soundfile %s" % fname)
    b.play_sound_file(0,fname)

def run_program(b, fname):
    print("Running %s" % fname)
    b.start_program(fname)
    
def delete_file(b, fname):
    b.delete(fname)
    print("Deleted %s" % fname)
    
def read_file(b, fname):
    with FileReader(b, fname) as r:
        with open(fname, 'wb') as f:
            for data in r:
                f.write(data)

class NXTListing(Gtk.ListStore):

    def __init__(self, brick):
        Gtk.ListStore.__init__(self, str, str)
        self.set_sort_column_id(0, Gtk.SortType(Gtk.SortType.ASCENDING))
        self.populate(brick, '*.*')

    def populate(self, brick, pattern):
        f = FileFinder(brick, pattern)
        for (fname, size) in f:
            self.append((fname, str(size)))

def write_file(b, fname, data):
    w = FileWriter(b, fname, len(data))
    print 'Pushing %s (%d bytes) ...' % (fname, w.size),
    sys.stdout.flush()
    w.write(data)
    print 'wrote %d bytes' % len(data)
    w.close()
        
def write_files(b, names):
    for fname in names.split('\r\n'):
        if fname:
            print 'File:', fname
            bname = os.path.basename(fname)
            url = urllib2.urlopen(fname)
            try:
                data = url.read()
            finally:
                url.close()
            print 'name %s, size: %d ' % (bname, len(data))
            write_file(b, bname, data)

class NXT_FileMgr(Gtk.Window):
 ### FIXME
 ###   TARGETS = Gtk.target_list_add_uri_targets()

    def __init__(self, brick):
        Gtk.Window.__init__(self)
        self.set_default_size(WIN_WIDTH, WIN_HEIGHT)
        self.set_resizable(False)
        self.brick = brick
        self.set_border_width(6)
        self.selected_file = None

        self.nxt_filelist = NXTListing(brick)
        h = Gtk.Grid()
        h.set_orientation(Gtk.Orientation.VERTICAL)

        self.brick_button = Gtk.Button(label=str(brick.sock))
        self.brick_button.connect("clicked", self.reload_filelist)
        h.add(self.brick_button)
        h.add(self.make_file_panel(str(brick.sock), self.nxt_filelist))
        h.add(self.make_button_panel())
        
        self.add(h)
        self.connect('destroy', self.quit)

    def make_button_panel(self):
        vb = Gtk.Box(Gtk.Orientation.HORIZONTAL, 0)     
 
        self.delete_button = Gtk.Button(label="Remove")
        self.delete_button.connect("clicked", self.remove_file)
        vb.pack_start(self.delete_button, True, True, 10)

        self.add_button = Gtk.Button(label="Add")
        self.add_button.connect("clicked", self.add_file)
        vb.pack_start(self.add_button, True, True, 10)

        self.exec_button = Gtk.Button(label="Execute")
        self.exec_button.connect("clicked", self.execute_file)
        vb.pack_start(self.exec_button, True, True, 10)

        return vb

    def make_file_list(self):
        tv = Gtk.TreeView()
        tv.set_headers_visible(True)
        tv.set_property('fixed_height_mode', True)
        r = Gtk.CellRendererText()
        c = Gtk.TreeViewColumn('File name', r, text=0)
        c.set_fixed_width(FILENAME_WIDTH)
        c.set_min_width(FILENAME_MINWIDTH)
        c.set_max_width(FILENAME_MAXWIDTH)
        c.set_resizable(True)
        c.set_sizing(Gtk.TreeViewColumnSizing.FIXED)
        tv.append_column(c)
        r = Gtk.CellRendererText()
        c = Gtk.TreeViewColumn('Bytes', r, text=1)
        c.set_resizable(True)
        c.set_fixed_width(FILESIZE_WIDTH)
        c.set_min_width(FILESIZE_MINWIDTH)
        c.set_max_width(FILESIZE_MAXWIDTH)
        c.set_sizing(Gtk.TreeViewColumnSizing.FIXED)
        tv.append_column(c)

### FIXME
#        tv.enable_model_drag_source(Gtk.gdk.BUTTON1_MASK, self.TARGETS,
#        Gtk.gdk.ACTION_DEFAULT | Gtk.gdk.ACTION_MOVE)
#        tv.enable_model_drag_dest(self.TARGETS, Gtk.gdk.ACTION_COPY)
#        tv.connect("drag_data_get", self.drag_data_get_data)

        tv.connect("drag_data_received", self.drag_data_received_data)
        tv.connect("row_activated", self.row_activated_action)
        return tv

    def make_file_panel(self, name, model):
        v = Gtk.Box(Gtk.Orientation.VERTICAL, 0)     
        tv = self.make_file_list()
        tv.set_model(model)
        select = tv.get_selection()
        select.connect("changed", self.on_tree_selection_changed)
        
        s = Gtk.ScrolledWindow()
        s.set_min_content_width(FILELIST_MINWIDTH)
        s.set_max_content_width(min(FILENAME_MAXWIDTH+FILESIZE_MAXWIDTH, FILELIST_MAXWIDTH))
        s.set_min_content_height(FILELIST_HEIGHT)
        s.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        s.add(tv)
        s.set_border_width(2)
        v.pack_start(s, True, False, 0)
        return v

    def choose_files(self):
        dialog = Gtk.FileChooserNative();
        dialog.new("Add File", self, Gtk.FileChooserAction.OPEN, None, None)
        dialog.set_transient_for(self)
        dialog.set_select_multiple(False)
        res = dialog.run()
        if res == Gtk.ResponseType.ACCEPT:
            ### Handle single file download for now
            uri = dialog.get_uri()
            print("You selected", uri)
            write_files(self.brick, uri)
        else:
            print("Add File Cancelled")
        dialog.destroy()

    def on_tree_selection_changed(self, selection):
        model, treeiter = selection.get_selected()
        if treeiter != None:
            print("You selected %s (%s bytes)" % (model[treeiter][0], model[treeiter][1]))
            self.selected_file = model[treeiter][0]
        else:
            self.selected_file = None
        
    def drag_data_get_data(self, treeview, context, selection, target_id,
        etime):
        treeselection = treeview.get_selection()
        model, iter = treeselection.get_selected()
        data = model.get_value(iter, 0)
        print data
        selection.set(selection.target, 8, data)

    def drag_data_received_data(self, treeview, context, x, y, selection,
        info, etime):
        if context.action == Gtk.gdk.ACTION_COPY:
            write_files(self.brick, selection.data)
        # FIXME: update file listing after writing files
        # FIXME: finish context

    def row_activated_action(self, treeview, context, selection):
        self.execute_file(selection)

    def	execute_file(self, widget):
        if self.selected_file != None:
            name = ''
            ext = ''
###            print("Attempting to execute file...%s" % self.selected_file)
            try:
                name, ext = self.selected_file.split('.')
            except:
                print("No file extension")
            finally:
                if ext == 'rso':
                    play_soundfile(self.brick,self.selected_file)
                elif ext == 'rxe':
                    run_program(self.brick,self.selected_file)
                    self.brick = None
                    self.nxt_filelist.clear()
                else:
                    print("Can't execute unknown file type")    
                        
    def	remove_file(self, widget):
        if self.selected_file != None:
            print("Removing file...%s" % self.selected_file)
            delete_file(self.brick,self.selected_file)
            self.selected_file = None
            self.nxt_filelist.clear()
            self.nxt_filelist.populate(self.brick, '*.*')

    def	add_file(self, widget):
        print("Adding file...")
        self.choose_files()
        self.selected_file = None
        self.nxt_filelist.clear()
        self.nxt_filelist.populate(self.brick, '*.*')

    def	reload_filelist(self, widget):
        print("Reloading filelist...")
        if self.brick != None:
            self.brick.sock.close()
        self.brick = None
        self.nxt_filelist.clear()
        self.brick = nxt.locator.find_one_brick(keyword_arguments.get('host',None))
        self.nxt_filelist.populate(self.brick, '*.*')

    def quit(self, w):
        'Quit the program'
        self.brick.sock.close()
        Gtk.main_quit()

if __name__ == '__main__':
    # FIXME: add dialog with progress bar when scanning bluetooth devices
    arguments, keyword_arguments = parse_command_line_arguments(sys.argv)

    if '--help' in arguments:
        print '''nxt_filemgr -- Simple GUI to manage files on a LEGO Mindstorms NXT
Usage:	nxt_filemgr [--host <macaddress>]'''
        exit(0)

    brick = nxt.locator.find_one_brick(keyword_arguments.get('host',None))
    win = NXT_FileMgr(brick)
    win.show_all()
    Gtk.main()
